#!/usr/bin/python3
SVER = '3.0.0_dev5'
# Revert %%% locations

##############################################################################
# scatool - Supportconfig Analysis (SCA) Tool
# Copyright (c) 2023 SUSE LLC
#
# Description:  Runs and analyzes local or remote supportconfigs
# Modified:     2023 Sep 20
#
##############################################################################
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; version 2 of the License.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, see <http://www.gnu.org/licenses/>.
#
#  Authors/Contributors:
#	Jason Record <jason.record@suse.com>
#
##############################################################################

import os
import re
import sys
import glob
import json
import uuid
import tarfile
import signal
import shutil
import datetime
import socket
import time
import getopt
import smtplib
import subprocess
import configparser
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication

width = 0
description_width = 0
progress_bar_active = True
report_file_path = ''
email_addr_list = ''
remove_archive = False
analyze_server = False
output_type = 'html'
config_file = '/home/opt/gitwork/sca-server-report/config/scatool.conf'
analysis_datetime = datetime.datetime.now()

def separator_line(use_char = '#'):
	print("{}".format(use_char*width))

def title():
	separator_line()
	print("#   SCA Tool v" + SVER)
	separator_line()
	print()

def usage():
	print("Usage: scatool [OPTIONS] [-s]|[archive|server]")
	display = "  {:33} {}"
	print()
	print("OPTIONS")
	print(display.format('-h, --help', "Displays this screen"))
	print(display.format('-b, --batch', "Batch mode that disables the progress bar"))
	print(display.format('-e <list>, --email <list>', "Send the SCA Report file to email address(es) provided. Comma separated list"))
	print(display.format('-o <path>, --output <path>', "HTML report output directory (OUTPUT_PATH)"))
	print(display.format('-p, --summary', "Print a pattern summary"))
	print(display.format('-r, --remove', "Remove archive files (REMOVE_ARCHIVE) leaving only the SCA Report file"))
	print(display.format('-s, --server', "Analyze the local server"))
	print(display.format('-t, --type', "SCA Report file output type, options: json, html. Default: html"))
	print(display.format('-l <level>, --log_level <level>', "Set log level, default: Normal"))
	print(display.format('', "0 Quiet, 1 Minimal, 2 Normal, 3 Verbose, 4 Debug"))
	print()

def option_error(msg):
	print(msg)
	print()
	usage()
	sys.exit(1)

def signal_handler(sig, frame):
	print("\n\nAborting...\n")
	sys.exit(1)

def config_entry(_entry, trailer = ''):
	formatted_entry = _entry.strip('\"\'')
	if( len(trailer) > 0 ):
		if len(formatted_entry) > 0:
			if not formatted_entry.endswith(trailer):
				formatted_entry = formatted_entry + str(trailer)
#	print("config_entry: Entry={}, Entry Size={}, Trailer={}, formatted_entry={}, formatted_entry size={}".format(_entry, len(_entry), trailer, formatted_entry, len(formatted_entry)))
	return formatted_entry

class ProgressBar():
	"""Initialize and update progress bar class"""

	def __init__(self, prefix, total):
		self.base_len = int(width)
		self.desc_width = int(description_width) + 1
		self.bar_width = self.base_len
		self.prefix = prefix
		self.prefix_size = len(self.prefix)
		self.total = int(total)
		self.count = 0
		self.out = sys.stdout
		if self.prefix_size > self.desc_width:
			self.bar_width = self.base_len - self.prefix_size - 2
		else:
			self.bar_width = self.base_len - self.desc_width - 2
		self.display = "{:" + str(self.desc_width) + "s}[{}{}] {:3g}% {:3g}/{}"
#		print("** ProgressBar base_len={}, bar_width={}, desc_width={}, prefix_size={}, display={}".format(self.base_len, self.bar_width, self.desc_width, self.prefix_size, self.display))

	def __str__(self):
		return 'class %s(\n  prefix=%r \n  bar_width=%r \n  total=%r\n)' % (self.__class__.__name__, self.prefix, self.bar_width, self.total)

	def set_prefix(self, _prefix):
		self.prefix = _prefix
		if ( self.bar_width_orig == self.base_len ):
			self.bar_width = self.base_len - self.prefix_size - 2
		else:
			self.bar_width = self.bar_width_orig

	def set_total(self, _new_total):
		self.total = _new_total

	def inc_count(self, increment = 1):
		"""Increments one by default"""
		if self.count < self.total:
			self.count += increment

	def get_total(self):
		return self.total

	def get_count(self):
		return self.count

	def update(self):
		percent_complete = int(100*self.count/self.total)
		current_progress = int(self.bar_width*self.count/self.total)
		print(self.display.format(self.prefix, "#"*current_progress, "."*(self.bar_width-current_progress), percent_complete, self.count, self.total), end='\r', file=self.out, flush=True)

	def finish(self):
		if self.count != self.total:
			self.count = self.total
			self.update()
		print("", flush=True, file=self.out)

class DisplayMessages():
	"Display message string for a given log level"
	LOG_QUIET = 0	# turns off messages
	LOG_MIN = 1	# minimal messages
	LOG_NORMAL = 2	# normal, but significant, messages
	LOG_VERBOSE = 3	# detailed messages
	LOG_DEBUG = 4	# debug-level messages
	LOG_LEVELS = {0: "Quiet", 1: "Minimal", 2: "Normal", 3: "Verbose", 4: "Debug" }

	def __init__(self):
		self.level = self.LOG_MIN # instance default
		self.desc_width = 30 # instance default
		self.msg_display = "{:" + str(self.desc_width) + "}"
		self.msg_display_pair = self.msg_display + " = {}"
#		print("** DisplayMessages desc_width={}, msg_display={}, msg_display_pair={}".format(self.desc_width, self.msg_display, self.msg_display_pair))

	def __str__ (self):
		return "class %s(level=%r)" % (self.__class__.__name__,self.level)

	def set_width(self, width_value):
		self.desc_width = width_value
		self.msg_display = "{:" + str(self.desc_width) + "}"
		self.msg_display_pair = self.msg_display + " = {}"

	def get_level(self):
		return self.level

	def get_level_str(self):
		return self.LOG_LEVELS[self.level]

	def set_level(self, level):
		if( level >= self.LOG_DEBUG ):
			self.level = self.LOG_DEBUG
		else:
			self.level = level

	def validate_level(self, level):
		validated_level = -1
		if( level.isdigit() ):
			validated_level = int(level)
		else:
			argstr = level.lower()
			if( argstr.startswith("qui") ):
				validated_level = self.LOG_QUIET
			elif( argstr.startswith("min") ):
				validated_level = self.LOG_MIN
			elif( argstr.startswith("norm") ):
				validated_level = self.LOG_NORMAL
			elif( argstr.startswith("verb") ):
				validated_level = self.LOG_VERBOSE
			elif( argstr.startswith("debug") ):
				validated_level = self.LOG_DEBUG

		return validated_level


	def __write_paired_msg(self, level, msgtag, msgstr):
		if( level <= self.level ):
			print(self.msg_display_pair.format(msgtag, msgstr))

	def __write_msg(self, level, msgtag):
		if( level <= self.level ):
			print(self.msg_display.format(msgtag))

	def quiet(self, msgtag = None, msgstr = None):
		"Write messages even if quiet is set"
		if msgtag:
			if msgstr:
				self.__write_paired_msg(self.LOG_QUIET, msgtag, msgstr)
			else:
				self.__write_msg(self.LOG_QUIET, msgtag)
		else:
			if( self.level >= self.LOG_QUIET ):
				print()

	def min(self, msgtag = None, msgstr = None):
		"Write the minium amount of messages"
		if msgtag:
			if msgstr:
				self.__write_paired_msg(self.LOG_MIN, msgtag, msgstr)
			else:
				self.__write_msg(self.LOG_MIN, msgtag)
		else:
			if( self.level >= self.LOG_MIN ):
				print()

	def normal(self, msgtag = None, msgstr = None):
		"Write normal, but significant, messages"
		if msgtag:
			if msgstr:
				self.__write_paired_msg(self.LOG_NORMAL, msgtag, msgstr)
			else:
				self.__write_msg(self.LOG_NORMAL, msgtag)
		else:
			if( self.level >= self.LOG_NORMAL ):
				print()

	def verbose(self, msgtag = None, msgstr = None):
		"Write more verbose informational messages"
		if msgtag:
			if msgstr:
				self.__write_paired_msg(self.LOG_VERBOSE, msgtag, msgstr)
			else:
				self.__write_msg(self.LOG_VERBOSE, msgtag)
		else:
			if( self.level >= self.LOG_VERBOSE ):
				print()

	def debug(self, msgtag = None, msgstr = None):
		"Write all messages, including debug level"
		if msgtag:
			if msgstr:
				self.__write_paired_msg(self.LOG_DEBUG, msgtag, msgstr)
			else:
				self.__write_msg(self.LOG_DEBUG, msgtag)
		else:
			if( self.level >= self.LOG_DEBUG ):
				print()

class SupportconfigAnalysis():
	RESULT_ELEMENT = ["META_CLASS", "META_CATEGORY", "META_COMPONENT", "PATTERN_ID", "PRIMARY_LINK", "OVERALL", "OVERALL_INFO", "META_LINK_"]
	SEV_TABLE = {'-2': 'temp', '-1': 'partial', '0': 'success', '1': 'recommend', '2': 'promotion', '3': 'warning', '4': 'critical', '5': 'error', '6': 'ignore' }

	def __init__(self, msg, config, extracted_path):
		self.msg = msg
		self.config = config
		self.json_data = {}
		self.sca_patterns_path = config_entry(config.get("Common", "sca_pattern_path"), '/')
		self.location = extracted_path
		self.analysis_datetime = datetime.datetime.now()
		self.distro_info = {'serverName': 'Unknown', 'hardWare': 'Unknown', 'virtualization': 'None', 'Summary': '', 'timeArchiveRun': "0000-00-00 00:00:00"}
		self.distro_info['timeAnalysis'] = str(self.analysis_datetime.year) + "-" + str(self.analysis_datetime.month).zfill(2) + "-" + str(self.analysis_datetime.day).zfill(2) + " " + str(self.analysis_datetime.hour).zfill(2) + ":" + str(self.analysis_datetime.minute).zfill(2) + ":" + str(self.analysis_datetime.second).zfill(2)
		self.results = {}
		self.runtime_error_list = []
		self.pattern_stats = {
			'total': 0,
			'applicable': 0,
			'applied': 0,
			'runtime_errors': 0,
			self.SEV_TABLE['-2']: 0,
			self.SEV_TABLE['-1']: 0,
			self.SEV_TABLE['0']: 0,
			self.SEV_TABLE['1']: 0,
			self.SEV_TABLE['2']: 0,
			self.SEV_TABLE['3']: 0,
			self.SEV_TABLE['4']: 0,
			self.SEV_TABLE['5']: 0,
			self.SEV_TABLE['6']: 0,
			'filter': []
		}
		self.products_list = self.__get_products_list()
		self.all_patterns = self.__get_available_patterns()
		self.pattern_filtered_directories = self.__get_pattern_filtered_directories()
		self.applicable_patterns = self.__get_applicable_patterns()
		self.__apply_patterns()

	# runpats gets the pattern results. runpats calls patternPreProcessor
	# getHtml(htmlOutputFile, self.location, supportconfigPath.split("/")[-1])
	# getHtml calls getClasses
	# email the report file
	# delete the archive and directory as needed


	def __str__ (self):
		pattern = '''
Class instance of {}
  sca_patterns_path = {}
  location = {}
  distro_info = {}\n
  products_list = {}\n
  patterns_available = {}
  pattern_filtered_directories = {}
  applicable_patterns = {}
  pattern_stats = {}
'''
		return pattern.format(self.__class__.__name__, self.sca_patterns_path, self.location, self.distro_info, self.products_list, self.patterns_available, self.pattern_filtered_directories, str(len(self.applicable_patterns)), self.pattern_stats)

	def get_results(self):
		return self.json_data

	def __parse_results_output(self, out, error, pat):
		output = {}
		error_display = "{} -- {}: {}"
		output['output_str'] = str(out)
		if error == "":
			pattern_return_list = out.strip().split("|")

			if( len(pattern_return_list) < len(self.RESULT_ELEMENT) ):
				output['valid'] = False
				output['error_tag'] = 'Insufficient output elements'
				output['error_str'] = str(error)
				self.runtime_error_list.append(error_display.format(pat, output['error_tag'], output['error_str']))
				self.pattern_stats['runtime_errors'] += 1
				self.results[pat] = output
				return False

			missing_elements = []
			for output_element in pattern_return_list:
				found = False
				for i in range(0, len(self.RESULT_ELEMENT)):
					if output_element.startswith(self.RESULT_ELEMENT[i]):
						found = True
				if not found:
					output['valid'] = False
					output['error_tag'] = 'Invalid output element'
					output['error_str'] = output_element
					self.runtime_error_list.append(error_display.format(pat, output['error_tag'], output['error_str']))
					self.pattern_stats['runtime_errors'] += 1
					self.results[pat] = output
					return False

			#if overall outcome of pattern was valid
			output['valid'] = True
			output['error_tag'] = 'None'
			output['error_str'] = 'None'
			for o in pattern_return_list:
				key, value = o.split("=", 1)
				output[key] = value
			self.pattern_stats[self.SEV_TABLE[str(output['OVERALL'])]] += 1
			if int(output['OVERALL']) >= 0 and int(output['OVERALL']) < 5:
				self.pattern_stats['applied'] += 1
			self.results[pat] = output
			return True
		else:
			output['valid'] = False
			output['error_tag'] = 'Output error'
			output['error_str'] = error
			self.runtime_error_list.append(error_display.format(pat, output['error_tag'], output['error_str']))
			self.pattern_stats['runtime_errors'] += 1
			self.results[pat] = output
			return False

	def __apply_patterns(self):
		pattern_count = 0
		output = {}
		self.pattern_stats['applicable'] = len(self.applicable_patterns)
		verbose_line = '{0:6} {1:>5} of {2} {3}'
		pattern_skipped = False

		self.msg.min('Pattern Filter', ' '.join(self.pattern_stats['filter']))

		if( msg.get_level() >= msg.LOG_VERBOSE ):
			msg.verbose('Analyzing Supportconfig', 'In Progress')
		elif( msg.get_level() >= msg.LOG_MIN ):
			if progress_bar_active:
				ascbar = ProgressBar("Analyzing Supportconfig:", self.pattern_stats['applicable'])
			else:
				msg.min('Analyzing Supportconfig', 'In Progress')

		for test_pattern in self.applicable_patterns:
			pattern_count += 1
			try:
				if test_pattern.endswith("README"):
					pattern_skipped = True
				else:
					cmd = test_pattern + " -p " + self.location
					self.msg.debug()
					self.msg.debug(' Process Command', cmd)
					p = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
					out, error = p.communicate()
					pattern_is_valid = self.__parse_results_output(out, error, test_pattern)

				#call parseOutput to see if output was expected
				if( msg.get_level() >= msg.LOG_VERBOSE ):
					if pattern_skipped:
						self.msg.verbose(verbose_line.format('Skip:', pattern_count, self.pattern_stats['total'], test_pattern))
						pattern_skipped = False
					else:
						if pattern_is_valid:
							self.msg.debug(" Output", self.results[test_pattern]['output_str'])
							self.msg.verbose(verbose_line.format('Done:', pattern_count, self.pattern_stats['applicable'], test_pattern))
						else:
							self.msg.debug(" Output", self.results[test_pattern]['error_str'])
							self.msg.verbose(verbose_line.format('ERROR:', pattern_count, self.pattern_stats['applicable'], test_pattern + " - " + str(self.results[test_pattern]['error_tag'])))
				elif( msg.get_level() >= msg.LOG_MIN ):
					if progress_bar_active:
						ascbar.inc_count()
						ascbar.update()
			except Exception as e:
				output['valid'] = False
				output['error_tag'] = 'Runtime error'
				output['error_str'] = str(e)
				self.results[test_pattern] = output
				self.runtime_error_list.append(test_pattern + " -- Pattern runtime error: " + str(e))
				self.pattern_stats['runtime_errors'] += 1
				self.msg.verbose(verbose_line.format('ERROR:', pattern_count, self.pattern_stats['applicable'], self.runtime_error_list[-1]))

		#make output look nice
		if( msg.get_level() > msg.LOG_QUIET and msg.get_level() <= msg.LOG_NORMAL ):
			if progress_bar_active:
				ascbar.finish()

		if( msg.get_level() >= msg.LOG_VERBOSE ):
			msg.verbose()
			separator_line('-')
		self.msg.normal('Total Patterns', str(self.pattern_stats['total']))
		self.msg.normal('Filtered Patterns', str(self.pattern_stats['applicable']))
		self.msg.normal('+ Critical', str(self.pattern_stats['critical']))
		self.msg.normal('+ Warning', str(self.pattern_stats['warning']))
		self.msg.normal('+ Recommended', str(self.pattern_stats['recommend']))
		self.msg.verbose('+ Promotion', str(self.pattern_stats['promotion']))
		self.msg.normal('+ Success', str(self.pattern_stats['success']))
		self.msg.verbose('+ Error', str(self.pattern_stats['error']))
		self.msg.verbose('+ Ignore', str(self.pattern_stats['ignore']))
		self.msg.verbose('+ Partial', str(self.pattern_stats['partial']))
		self.msg.verbose('+ Temporary', str(self.pattern_stats['temp']))
		self.msg.verbose('+ Exec Errors', str(self.pattern_stats['runtime_errors']))
		self.msg.min('Applicable to Supportconfig', str(self.pattern_stats['applied']))

		self.msg.min()
		level_now = msg.get_level()
		if( level_now >= msg.LOG_MIN ):
			if self.pattern_stats['runtime_errors'] > 0:
				self.msg.min('Pattern Execution Errors:', str(self.pattern_stats['runtime_errors']))
				separator_line('-')
				for pattern_error_str in self.runtime_error_list:
					print(pattern_error_str)
					print()
		self.json_data['pattern_stats'] = self.pattern_stats
		self.json_data['results'] = self.results

	def __get_available_patterns(self):
		file_list = []
		for root, dirs, files in os.walk(self.sca_patterns_path):
			for name in files:
				if "README" in name:
					continue
				else:
					file_list.append(os.path.join(root, name))
		file_list.sort()
		self.pattern_stats['total'] = len(file_list)
		return file_list

	def __get_pattern_filtered_directories(self):
		pattern_directories = [self.sca_patterns_path + 'local/']
		for product_included in self.products_list:
			base_pattern_path = str(self.sca_patterns_path) + str(product_included['patternTag']) + "/"
			pattern_filter_path = base_pattern_path + str(product_included['tag']) + str(product_included['vermajor']) + "all/"
			if os.path.isdir(pattern_filter_path):
				pattern_directories.append(pattern_filter_path)
			pattern_filter_path = base_pattern_path + str(product_included['tag']) + str(product_included['vermajor']) + "sp" + str(product_included['verminor']) + "/"
			if os.path.isdir(pattern_filter_path):
				pattern_directories.append(pattern_filter_path)

		pattern_directories = list(set(pattern_directories)) #create a unique sorted list
		self.msg.debug('Pattern Filtered Directories', ' '.join(pattern_directories))
		pattern_definition_filter = []
		for test_directory in pattern_directories:
			pattern_definition_filter.append(test_directory.split("/")[-2])
		self.pattern_stats['filter'] = sorted(pattern_definition_filter)

		return pattern_directories

	def __get_applicable_patterns(self):
		pattern_file_list = []
		for check_pattern in self.all_patterns:
			for filtered_directory in self.pattern_filtered_directories:
				if filtered_directory in check_pattern:
					pattern_file_list.append(check_pattern)
		return pattern_file_list

	def __get_products_list(self):
		products_found = []
		#load basic-environment.txt
		try:
			with open(self.location + "/basic-environment.txt") as f:
				basic_env_file = f.read().splitlines()
				f.close()
		except:
			basic_env_file = []

		product_info = {'tag': 'sle', 'patternTag': 'SLE', 'nameTag': 'Distribution:', 'name': '', 'versionTag': 'Service Pack:', 'version': '', 'vermajor': '', 'verminor': ''}

		#read basic-environment line by line to pull out data.
		in_date = False
		in_uname = False
		in_os_release = False
		in_suse_release = False
		for line in basic_env_file:
			if "Script Version:" in line:
				self.distro_info['supportconfigVersion'] = line.split(':')[-1].strip()
			elif line.startswith("Hardware:"):
				self.distro_info['hardWare'] = line.split(":")[1].strip()
			elif line.startswith("Hypervisor:"):
				self.distro_info['virtualization'] = line.split(":")[1].strip()
			elif line.startswith("Identity:"):
				self.distro_info['vmIdentity'] = line.split(":")[1].strip()
			elif "/bin/date" in line:
				in_date = True
			elif "/bin/uname -a" in line:
				in_uname = True
			elif "/etc/os-release" in line:
				in_os_release = True
			elif( in_date ):
				if "#==[" in line:
					in_date = False
				else:
					dateLine = line
					dateLine = re.sub("\s+", " ", dateLine.rstrip("\n")) # replace multiple whitespace with single space
					tmp = dateLine.split() # split into list based on a space
					if( len(tmp) >= 4 ):
						tmpMonth = tmp[1].strip()
						if "Jan" in tmpMonth:
							tmpMonth = "01"
						elif "Feb" in tmpMonth:
							tmpMonth = "02"
						elif "Mar" in tmpMonth:
							tmpMonth = "03"
						elif "Apr" in tmpMonth:
							tmpMonth = "04"
						elif "May" in tmpMonth:
							tmpMonth = "05"
						elif "Jun" in tmpMonth:
							tmpMonth = "06"
						elif "Jul" in tmpMonth:
							tmpMonth = "07"
						elif "Aug" in tmpMonth:
							tmpMonth = "08"
						elif "Sep" in tmpMonth:
							tmpMonth = "09"
						elif "Oct" in tmpMonth:
							tmpMonth = "10"
						elif "Nov" in tmpMonth:
							tmpMonth = "11"
						elif "Dec" in tmpMonth:
							tmpMonth = "12"
						self.distro_info['timeArchiveRun'] = tmp[-1].strip() + "-" + tmpMonth + "-" + tmp[2].strip().zfill(2) + " " + tmp[3].strip()
						in_date = False
			elif( in_uname ):
				if "#==[" in line:
					in_uname = False
				else:
					tmp = line.split()
					if( len(tmp) >= 3 ):
						self.distro_info['kernelVersion'] = tmp[2].strip()
						self.distro_info['serverName'] = tmp[1].strip()
						self.distro_info['osArch'] = tmp[-2].strip()
						in_uname = False
			elif( in_os_release ):
				if "#==[" in line:
					in_os_release = False
					product_info['name'] = str(self.distro_info['Summary']) + " (" + self.distro_info['osArch'] + ")"
				else:
					if line.lower().startswith("pretty_name"):
						self.distro_info['Summary'] = line.split('=')[-1].replace('"', '').strip()
					elif line.lower().startswith("version_id"):
						VERSION_ID_summary_info = line.replace('"', "").strip().split('=')[1].split('.')
						product_info['vermajor'] = str(VERSION_ID_summary_info[0])
						if( len(VERSION_ID_summary_info) > 1 ):
							product_info['verminor'] = str(VERSION_ID_summary_info[1])
						else:
							product_info['verminor'] = "0"
						product_info['version'] = product_info['verminor']

		# Look for SUSE release as a last resort
		if( len(self.distro_info['Summary']) == 0 ):
			for line in basic_env_file:
				if "/etc/SuSE-release" in line:
					in_suse_release = True
				elif( in_suse_release ):
					if "#==[" in line:
						in_suse_release = False
						product_info['name'] = str(self.distro_info['Summary'])
					else:
						if( len(self.distro_info['Summary']) > 0 ):
							if line.lower().startswith("version"):
								product_info['vermajor'] = line.split('=')[-1].replace('"', '').strip()
							elif line.lower().startswith("patchlevel"):
								product_info['verminor'] = line.split('=')[-1].replace('"', '').strip()
							product_info['version'] = product_info['verminor']
						else:
							self.distro_info['Summary'] = line.strip()

		products_found.append(product_info)

		del basic_env_file


		#load summary.xml
		try:
			with open(self.location + "/summary.xml") as f:
				summary_file = f.read().splitlines()
				f.close()
		except:
			summary_file = []

		product_start = re.compile(r'<product\s|<product>', re.IGNORECASE)
		product_end = re.compile(r'</product>', re.IGNORECASE)
		in_product = False

		#detect SLE for VMWARE
		product_name = re.compile(r'<summary>SUSE Linux Enterprise Server .* for VMware</summary>', re.IGNORECASE)
		product_version = re.compile(r'<version>.*</version>', re.IGNORECASE)
		summary_info = {'tag': 'vmw', 'patternTag': 'VMware', 'nameTag': 'Product:', 'name': '', 'versionTag': 'Version:', 'version': '', 'vermajor': '', 'verminor': ''}
		for line in summary_file:
			if( in_product ):
				if product_end.search(line):
					in_product = False
				elif product_name.search(line):
					try:
						summary_info['name'] = re.search(r'>(.+?)<', line).group(1).replace('-', ' ')
					except:
						True
				elif product_version.search(line):
					try:
						summary_info['version'] = re.search(r'>(.+?)<', line).group(1)
						if( "." in summary_info['version'] ):
							(summary_info['vermajor'], summary_info['verminor']) = summary_info['version'].split(".")
						else:
							summary_info['vermajor'] = summary_info['version']
							summary_info['verminor'] = "0"
					except:
						True
				if( summary_info['name'] and summary_info['version'] ):
					in_product = False
					products_found.append(summary_info)
					break
			elif product_start.search(line):
				in_product = True

		#detect SLE for SAP
		product_name = re.compile(r'<summary>SUSE LINUX Enterprise Server for SAP Applications.*</summary>', re.IGNORECASE)
		product_version = re.compile(r'<version>.*</version>', re.IGNORECASE)
		summary_info = {'tag': 'sap', 'patternTag': 'SAP', 'nameTag': 'Product:', 'name': '', 'versionTag': 'Version:', 'version': '', 'vermajor': '', 'verminor': ''}
		for line in summary_file:
			if( in_product ):
				if product_end.search(line):
					in_product = False
				elif product_name.search(line):
					try:
						summary_info['name'] = re.search(r'>(.+?)<', line).group(1).replace('-', ' ')
					except:
						True
				elif product_version.search(line):
					try:
						summary_info['version'] = re.search(r'>(.+?)<', line).group(1)
						if( "." in summary_info['version'] ):
							(summary_info['vermajor'], summary_info['verminor']) = summary_info['version'].split(".")
						else:
							summary_info['vermajor'] = summary_info['version']
							summary_info['verminor'] = "0"
					except:
						True
				if( summary_info['name'] and summary_info['version'] ):
					in_product = False
					products_found.append(summary_info)
					break
			elif product_start.search(line):
				in_product = True

		#get HAE information
		product_name = re.compile(r'<summary>SUSE Linux Enterprise High Availability Extension.*</summary>', re.IGNORECASE)
		product_version = re.compile(r'<version>.*</version>', re.IGNORECASE)
		summary_info = {'tag': 'hae', 'patternTag': 'HAE', 'nameTag': 'Product:', 'name': '', 'versionTag': 'Version:', 'version': '', 'vermajor': '', 'verminor': ''}
		for line in summary_file:
			if( in_product ):
				if product_end.search(line):
					in_product = False
				elif product_name.search(line):
					try:
						summary_info['name'] = re.search(r'>(.+?)<', line).group(1).replace('-', ' ')
					except:
						True
				elif product_version.search(line):
					try:
						summary_info['version'] = re.search(r'>(.+?)<', line).group(1)
						if( "." in summary_info['version'] ):
							(summary_info['vermajor'], summary_info['verminor']) = summary_info['version'].split(".")
						else:
							summary_info['vermajor'] = summary_info['version']
							summary_info['verminor'] = "0"
					except:
						True
				if( summary_info['name'] and summary_info['version'] ):
					in_product = False
					products_found.append(summary_info)
					break
			elif product_start.search(line):
				in_product = True

		#get SUSE Manager information
		# TO DO

		del summary_file
		self.distro_info['name'] = os.path.basename(self.location)
		self.distro_info['path'] = os.path.dirname(self.location)
		self.json_data['sc_info'] = self.distro_info
		self.json_data['prod_info'] = products_found
		if( self.msg.get_level() >= self.msg.LOG_DEBUG ):
			print()
			print("Distro Info: {}\n".format(self.distro_info))
			print("Products List")
			print("[")
			for summary_info in products_found:
				print(str(summary_info))
			print("]")
#			sys.exit()

		return products_found

def show_pattern_library(msg, location):
	total_count=0
	directory = {}
	file_list = []
	display = '{0:>17} : {1}'
	msg.min("Pattern Library Summary\n")
	msg.min(display.format('Pattern Directory', 'Count'))
	msg.min(display.format('=================', '====='))
	for root, dirs, files in os.walk(location):
		file_list = []
		for name in files:
			if "README" in name:
				continue
			else:
				file_list.append(os.path.join(root, name))
		if len(file_list) > 0:
			file_list.sort()
			directory[root] = file_list
			total_count += len(file_list)

	for _dir, _list in sorted(directory.items()):
		if( msg.get_level() >= msg.LOG_NORMAL ):
			msg.min(display.format(_dir, len(_list)))
			for _pat in _list:
				msg.normal(_pat)
		elif( msg.get_level() >= msg.LOG_MIN ):
			msg.min(display.format(os.path.basename(_dir), len(_list)))
		msg.normal()

	msg.quiet(display.format(total_count, 'Total Available Patterns'))
	msg.min()

def evaluate_supportconfig_given(msg, given_path):
	type_found = {'valid': False, 'type': '', 'source': ''}
	msg.debug("Evaluating", given_path)
	if os.path.exists(given_path):
		if os.path.isfile(given_path):
			type_found['valid'] = True
			type_found['type'] = 'file'
		elif os.path.isdir(given_path):
			type_found['valid'] = True
			type_found['type'] = 'dir'
		type_found['source'] = os.path.abspath(given_path)
	else:
		cmd = "ping -c1 -w1 " + given_path
		msg.verbose("Pinging", given_path)
		msg.debug("Process Command", cmd)
		ping_server = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		stdout, stderr = ping_server.communicate()
		if ping_server.returncode == 0:
			type_found['valid'] = True
			type_found['type'] = 'remote'
			type_found['source'] = given_path

	msg.debug("Supportconfig Evaluation", type_found)
	return type_found

def extract_supportconfig(msg, tarball):
	path_in_tarball = ''
	msg.normal("Extracting File", tarball)
	cmd = "file --brief --mime-type " + tarball
	msg.debug('Process Command', cmd)
	process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
	stdout, stderr = process.communicate()
	file_type = stdout.strip()
	msg.debug('File Type', file_type)
	archdir = os.path.dirname(tarball)
	cmd = "tar -xvf "  + tarball + " -C " + archdir
	msg.debug('Process Command', cmd)
	process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
	stdout, stderr = process.communicate()
	outfile = stdout.splitlines()[0]
	rc = process.returncode
	if( rc > 0 ):
		print("+ Error: Cannot extract tar file", file=sys.stderr)
		print(stderr, file=sys.stderr)
		print(file=sys.stderr)
		sys.exit(7)
	else:
		path_in_tarball = archdir + '/' + os.path.dirname(outfile)
		msg.verbose('Embedded Directory', path_in_tarball)

	return path_in_tarball

def valid_supportconfig_dir(msg, check_dir):
	test_files = ['basic-environment.txt', 'rpm.txt']
	for test_file in test_files:
		file_path = check_dir + '/' + test_file
		if not os.path.isfile(file_path):
			#not a supportconfig. quit out
			msg.min("Error: Invalid supportconfig archive - missing " + file_path)
			return False

	msg.verbose("Valid Supportconfig", check_dir)
	return True

def i_am_root():
	if not os.environ.get("SUDO_UID") and os.geteuid() != 0:
		return False
	return True

def get_local_supportconfig(msg, config):
	local_hostname = str(os.uname()[1])
	msg.min('Running Supportconfig On', local_hostname)
	analysis_datetime = datetime.datetime.now()
	date_stamp = analysis_datetime.strftime("%y%m%d")
	time_stamp = str(analysis_datetime.hour).zfill(2) + str(analysis_datetime.minute).zfill(2) + str(analysis_datetime.second).zfill(2)
	supportconfig_output_lines = config_entry(config.get("Supportconfig", "output_lines"))
	supportconfig_filename_prefix = config_entry(config.get("Supportconfig", "filename_prefix"))
	local_supportconfig_path = config_entry(config.get("Supportconfig", "path_local"), '/')
	local_supportconfig_name = local_hostname + "_" + str(date_stamp) + "_" + str(time_stamp)
	supportconfig_path = local_supportconfig_path + supportconfig_filename_prefix + local_supportconfig_name

	try:
		cmd = "supportconfig -bB " + local_supportconfig_name + " -t " + local_supportconfig_path
		msg.debug('Process Command', cmd)
		p = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
	#if we cannot run supportconfig
	except Exception:
		print("Error: Cannot run supportconfig\n", file=sys.stderr)
		return
	condition = True

	if( msg.get_level() == msg.LOG_MIN ):
		if progress_bar_active:
			scbar = ProgressBar("Gathering Supportconfig: ", supportconfig_output_lines)

	if( msg.get_level() >= msg.LOG_VERBOSE ):
		msg.verbose('Gathering Supportconfig', 'In Progress')
	elif( msg.get_level() >= msg.LOG_MIN ):
		if progress_bar_active:
			scbar = ProgressBar("Gathering Supportconfig: ", supportconfig_output_lines)
		else:
			msg.min('Gathering Supportconfig', 'In Progress')

	while condition:
		out = p.stdout.read(1)
		if out != '':
			if( msg.get_level() >= msg.LOG_VERBOSE ):
				sys.stdout.write(out)
				sys.stdout.flush()
			elif( msg.get_level() >= msg.LOG_MIN ):
				if out == "\n":
					if progress_bar_active:
						scbar.inc_count()
						scbar.update()
		condition = not bool(out == "" and p.poll() != None)

	if( msg.get_level() > msg.LOG_QUIET and msg.get_level() <= msg.LOG_NORMAL ):
		if progress_bar_active:
			scbar.finish()
	
	return supportconfig_path

class SCAReport():
	RESULT_ELEMENT = ["META_CLASS", "META_CATEGORY", "META_COMPONENT", "PATTERN_ID", "PRIMARY_LINK", "OVERALL", "OVERALL_INFO", "META_LINK_"]
	SEV_TABLE = {'-2': 'temp', '-1': 'partial', '0': 'success', '1': 'recommend', '2': 'promotion', '3': 'warning', '4': 'critical', '5': 'error', '6': 'ignore' }
	VALID_REPORT_TYPES = ['html', 'json']
	default_report_type = 'html'

	def __init__(self, msg, config):
		self.msg = msg
		self.config = config
		self.data = {}
		self.report_type = config_entry(config.get("Common", "report_output_type")).lower()
		self.report_path = config_entry(config.get("Common", "report_output_path"), '/')
		self.report_name = ''
		self.report_file = ''
		self.__validate_report_type()

	def __str__ (self):
		pattern = '''
Class instance of {}
  report_type = {}
  report_path = {}
  report_name = {}
  report_file = {}
'''
		return pattern.format(self.__class__.__name__, self.report_type, self.report_path, self.report_name, self.report_file)

	def __validate_report_type(self):
		valid = False
		for checking_type in self.VALID_REPORT_TYPES:
			if self.report_type == checking_type:
				valid = True
		if not valid:
			msg.min("\nWarning: Invalid report type - {}, using instance default ({})".format(self.report_type,self.default_report_type))
			self.report_type = self.default_report_type

	def __normalize_path(self, check_path):
		if check_path.endswith("/"):
			return check_path
		else:
			return check_path + "/"

	def set_type(self, updated_type):
		self.report_type = updated_type.lower()
		self.__validate_report_type()

	def set_path(self, updated_path):
		if os.path.exists(updated_path):
			self.report_path = self.__normalize_path(updated_path)
		else:
			msg.min("\nError: Path not found - {}, using default path".format(updated_path))

	def set_data(self, updated_data):
		self.data = updated_data
		if len(self.report_path) < 1:
			self.report_path = self.__normalize_path(self.data['sc_info']['path'])
		self.report_name = self.data['sc_info']['name']
		self.report_file = self.report_path + self.report_name + "." + self.report_type

	def __generate_json_report(self):
		with open(self.report_file, "w") as reportfile:
			json.dump(self.data, reportfile, ensure_asscii=False, indent=4)
			#%%% fails to write, no errors

	def __generate_html_report(self):
		pass

	def generate_report(self):
		if self.report_type == "html":
			self.__generate_html_report(self)
		elif self.report_type == "html":
			self.__generate_json_report(self)


##############################################################################
# Main
##############################################################################

def main(argv):
	"main entry point"
	global SVER, progress_bar_active, email_addr_list, remove_archive, analyze_server, config_file
	global width, description_width

	pattern_library = False

	if( os.path.exists(config_file) ):
		config.read(config_file)
		width = int(config_entry(config.get("Common", "display_width")))
		description_width = int(config_entry(config.get("Common", "description_width")))
		sca_library_path = config_entry(config.get("Common", "sca_library_path"), '/')
		sca_patterns_path = config_entry(config.get("Common", "sca_pattern_path"), '/')
		msg.set_width(description_width)
		config_logging = msg.validate_level(config_entry(config.get("Common", "log_level")))
		if( config_logging >= msg.LOG_QUIET ):
			msg.set_level(config_logging)
		else:
			msg.verbose("Warning: Invalid log level in config file, using instance default")
		sca_report = SCAReport(msg, config)

##################
#%%%
# Not setting environment variables here. 
# Work around: set the environment variables in bash terminal
	#	sys.path.append(os.path.abspath(sca_library_path + 'python'))
	#	os.environ['PYTHONPATH'] = os.path.abspath(sca_library_path + 'python')
	#	os.environ['PERL5LIB'] = os.path.abspath(sca_library_path + 'perl')
	#	os.environ['BASHLIB'] = os.path.abspath(sca_library_path + 'bash')
	else:
		title()
		print("Error: File not found - " + config_file + "\n")
		sys.exit(1)

	try:
		(optlist, args) = getopt.gnu_getopt(argv[1:], "hbe:o:pl:qrst:v", ["help", "batch", "email=", "output=", "summary", "log_level=", "quiet", "remove", "server", "type=", "verbose"])
	except getopt.GetoptError as exc:
		title()
		print("Error:", exc, file=sys.stderr)
		sys.exit(2)
	for opt, arg in optlist:
		if opt in {"-h", "--help"}:
			title()
			usage()
			sys.exit(0)
		elif opt in {"-b", "--batch"}:
			progress_bar_active = False
		elif opt in {"-e", "--email"}:
			email_addr_list = arg
		elif opt in {"-o", "--output"}:
			sca_report.set_path(arg)
		elif opt in {"-p", "--summary"}:
			pattern_library = True
		elif opt in {"-r", "--remove"}:
			remove_archive = True
		elif opt in {"-s", "--server"}:
			analyze_server = True
		elif opt in {"-t", "--type"}:
			sca_report.set_type(arg)
		elif opt in {"-q", "--quiet"}:
			msg.set_level(msg.LOG_QUIET)
		elif opt in {"-v", "--verbose"}:
			msg.set_level(msg.LOG_VERBOSE)
		elif opt in {"-l", "--log_level"}:
			user_logging = msg.validate_level(arg)
			if( user_logging >= msg.LOG_QUIET ):
				msg.set_level(user_logging)
			else:
				print("Warning: Invalid log level, using instance default")

	if( msg.get_level() > msg.LOG_QUIET ):
		title()

	if pattern_library:
		show_pattern_library(msg, sca_patterns_path)
		sys.exit(0)

	total_args_given = len(args)
	process_dirs = {} # key = supportconfig directory, value = the supportconfig tarball
	if total_args_given > 0:
		for given_source in args:
			supportconfig_data = evaluate_supportconfig_given(msg, given_source)
			supportconfig_dir = ''
			if supportconfig_data['valid']:
				if supportconfig_data['type'] == 'dir':
					supportconfig_dir = supportconfig_data['source']
					if valid_supportconfig_dir(msg, supportconfig_dir):
						process_dirs[supportconfig_dir] = ''
				elif supportconfig_data['type'] == 'file':
					supportconfig_dir = extract_supportconfig(msg, supportconfig_data['source'])
					if valid_supportconfig_dir(msg, supportconfig_dir):
						process_dirs[supportconfig_dir] = supportconfig_data['source']
				else:
					if i_am_root():
						print("Get remote supportconfig -- PENDING")
						print("Extract supportconfig")
						print("Create a supportconfig instance")
					else:
						msg.min("Evaluating Server", "Root user required for " + supportconfig_data['source'])
			else:
				msg.min("Error: Invalid supportconfig source - " + given_source)
	elif analyze_server:
		if i_am_root():
			given_source = get_local_supportconfig(msg, config)
			supportconfig_data = evaluate_supportconfig_given(msg, given_source)
			if supportconfig_data['valid']:
					supportconfig_dir = supportconfig_data['source']
					if valid_supportconfig_dir(msg, supportconfig_dir):
						process_dirs[supportconfig_dir] = ''
			else:
				msg.min("Error: Invalid supportconfig source - " + given_source)
		else:
			msg.min("Analyze Local Server", "Root user required to run supportconfig")

	else:
		usage()
		sys.exit(0)

	num_of_supportconfigs = len(process_dirs)
	if num_of_supportconfigs > 1:
		for supportconfig_directory, suppportconfig_tarball in process_dirs.items():
			msg.min("Processing Supportconfig", supportconfig_directory)
			sca_data = SupportconfigAnalysis(msg, config, supportconfig_directory)
			sca_results = sca_data.get_results()
			sca_report.set_data(sca_results)
			separator_line('=')
			msg.min()
			del sca_data
		msg.min()
	elif num_of_supportconfigs > 0:
		for supportconfig_directory, suppportconfig_tarball in process_dirs.items():
			msg.min("Processing Supportconfig", supportconfig_directory)
			sca_data = SupportconfigAnalysis(msg, config, supportconfig_directory)
			sca_results = sca_data.get_results()
			sca_report.set_data(sca_results)
			print(sca_report)
			sys.exit(1)
			json_obj = json.dumps(sca_results, indent = 4)
			print(json_obj)
			del sca_data
			
# Entry point
if __name__ == "__main__":
	signal.signal(signal.SIGINT, signal_handler)
	config = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())
	msg = DisplayMessages()
	main(sys.argv)

